// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: weekly_high_scores.sql

package db

import (
	"context"
)

const getHighScoreCounts = `-- name: GetHighScoreCounts :many
SELECT
    u.id AS user_id,
    u.name AS user_name,
    COALESCE(high_scores.count, 0) AS high_score_count
FROM users u
         LEFT JOIN (
    SELECT
        winner.user_id,
        COUNT(*) AS count
    FROM (
             SELECT
                 year,
                 week,
                 CASE
                     WHEN home_score >= away_score THEN home_user_id
                     ELSE away_user_id
                     END AS user_id,
                 GREATEST(home_score, away_score) AS score
             FROM matchups
             WHERE is_playoff = false
         ) AS winner
             JOIN (
        SELECT
            year,
            week,
            MAX(GREATEST(home_score, away_score)) AS max_score
        FROM matchups
        WHERE is_playoff = false
        GROUP BY year, week
    ) AS weekly_max
                  ON winner.year = weekly_max.year
                      AND winner.week = weekly_max.week
                      AND winner.score = weekly_max.max_score
    GROUP BY winner.user_id
) AS high_scores
                   ON u.id = high_scores.user_id
ORDER BY high_score_count DESC
`

type GetHighScoreCountsRow struct {
	UserID         string
	UserName       string
	HighScoreCount int64
}

func (q *Queries) GetHighScoreCounts(ctx context.Context) ([]GetHighScoreCountsRow, error) {
	rows, err := q.db.Query(ctx, getHighScoreCounts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetHighScoreCountsRow
	for rows.Next() {
		var i GetHighScoreCountsRow
		if err := rows.Scan(&i.UserID, &i.UserName, &i.HighScoreCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
